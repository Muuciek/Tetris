[1mdiff --git a/Tetris/src/DEFINE.hpp b/Tetris/src/DEFINE.hpp[m
[1mindex 1b22691..8155da1 100644[m
[1m--- a/Tetris/src/DEFINE.hpp[m
[1m+++ b/Tetris/src/DEFINE.hpp[m
[36m@@ -10,4 +10,6 @@[m
 #define BLOCK_SIZE 30[m
 [m
 #define GRID_START_POS_X 250[m
[31m-#define GRID_START_POS_Y 250[m
\ No newline at end of file[m
[32m+[m[32m#define GRID_START_POS_Y 100[m
[32m+[m[32m#define GRID_END_POS_Y 700[m
[32m+[m[32m#define GRID_END_POS_X 550[m
\ No newline at end of file[m
[1mdiff --git a/Tetris/src/States/cpp/GameState.cpp b/Tetris/src/States/cpp/GameState.cpp[m
[1mindex c2f30ea..609cfc5 100644[m
[1m--- a/Tetris/src/States/cpp/GameState.cpp[m
[1m+++ b/Tetris/src/States/cpp/GameState.cpp[m
[36m@@ -2,66 +2,102 @@[m
 #include "src/GameEngine/hpp/Game.hpp"[m
 #include "src/DEFINE.hpp"[m
 #include <iostream>[m
[32m+[m[32m#include <chrono>[m
[32m+[m[32m#include <random>[m
 [m
 namespace hgw[m
 {[m
[31m-	Figure::Figure(Figure::FigureType type, sf::Vector2f startPos, sf::Color color)[m
[32m+[m	[32mFigure::Figure(Figure::FigureType type, sf::Vector2f startPos, sf::Color color)[m[41m [m
 	{[m
[31m-		for (int i = 0; i < 4; i++)[m
[32m+[m		[32m//TODO: maybe delete all Pos vars and do position checking from grid coordinates[m
[32m+[m		[32m//e.g: if(coord.y > 20) stop moving[m
[32m+[m		[32mfigureColor = color;[m
[32m+[m		[32m_type_ = type;[m
[32m+[m
[32m+[m		[32mfor (int i = 0; i < 4; i++) //set size 30 x 30 and color[m
 		{[m
 			blocks[i].setSize(sf::Vector2f(BLOCK_SIZE, BLOCK_SIZE));[m
 			blocks[i].setFillColor(color);[m
 		}[m
[31m-		switch (type)[m
[32m+[m
[32m+[m		[32mswitch (type) //create figure shape based on type[m
 		{[m
 		case Figure::I:[m
[31m-			for (int i = 0; i < 4; i++)[m
[31m-			{		[m
[31m-				blocks[i].setPosition(startPos.x, startPos.y + i * BLOCK_SIZE);[m
[31m-			}[m
[32m+[m			[32mblocks[0].setPosition(startPos.x, startPos.y);[m
[32m+[m			[32mblocks[1].setPosition(startPos.x, startPos.y + BLOCK_SIZE);[m
[32m+[m			[32mblocks[2].setPosition(startPos.x, startPos.y + 2 * BLOCK_SIZE);[m
[32m+[m			[32mblocks[3].setPosition(startPos.x, startPos.y + 3 * BLOCK_SIZE);[m
[32m+[m
[32m+[m			[32mleftPos = blocks[0].getPosition(); //set border position to check overlapping[m
[32m+[m			[32mrightPos = blocks[0].getPosition();[m
[32m+[m			[32mdownPos = blocks[3].getPosition();[m
[32m+[m			[32mupPos = blocks[0].getPosition();[m
 			break;[m
 		case Figure::T:[m
[31m-			for (int i = 0; i < 3; i++)[m
[31m-			{[m
[31m-				blocks[i].setPosition(startPos.x + i * BLOCK_SIZE, startPos.y);[m
[31m-			}[m
[31m-			blocks[3].setPosition(startPos.x + BLOCK_SIZE, startPos.y + BLOCK_SIZE);[m
[32m+[m			[32mblocks[0].setPosition(startPos.x, startPos.y);[m
[32m+[m			[32mblocks[1].setPosition(startPos.x + BLOCK_SIZE, startPos.y);[m
[32m+[m			[32mblocks[2].setPosition(startPos.x + BLOCK_SIZE, startPos.y + BLOCK_SIZE);[m
[32m+[m			[32mblocks[3].setPosition(startPos.x + 2 * BLOCK_SIZE, startPos.y);[m
[32m+[m
[32m+[m			[32mleftPos = blocks[0].getPosition();[m
[32m+[m			[32mrightPos = blocks[3].getPosition();[m
[32m+[m			[32mdownPos = blocks[2].getPosition();[m
[32m+[m			[32mupPos = blocks[0].getPosition();[m
 			break;[m
 		case Figure::O:[m
[31m-			for (int i = 0; i < 2; i++)[m
[31m-			{[m
[31m-				blocks[i].setPosition(startPos.x + i * BLOCK_SIZE, startPos.y);[m
[31m-			}[m
[31m-			for (int i = 2; i < 4; i++)[m
[31m-			{[m
[31m-				blocks[i].setPosition(startPos.x + (i-2) * BLOCK_SIZE, startPos.y + BLOCK_SIZE);[m
[31m-			}[m
[32m+[m			[32mblocks[0].setPosition(startPos.x, startPos.y);[m
[32m+[m			[32mblocks[1].setPosition(startPos.x + BLOCK_SIZE, startPos.y);[m
[32m+[m			[32mblocks[2].setPosition(startPos.x, startPos.y + BLOCK_SIZE);[m
[32m+[m			[32mblocks[3].setPosition(startPos.x + BLOCK_SIZE, startPos.y + BLOCK_SIZE);[m
[32m+[m
[32m+[m			[32mleftPos = blocks[0].getPosition();[m
[32m+[m			[32mrightPos = blocks[1].getPosition();[m
[32m+[m			[32mdownPos = blocks[2].getPosition();[m
[32m+[m			[32mupPos = blocks[0].getPosition();[m
 			break;[m
 		case Figure::L:[m
[31m-			for (int i = 0; i < 3; i++)[m
[31m-			{[m
[31m-				blocks[i].setPosition(startPos.x, startPos.y + i * BLOCK_SIZE);[m
[31m-			}[m
[32m+[m			[32mblocks[0].setPosition(startPos.x, startPos.y);[m
[32m+[m			[32mblocks[1].setPosition(startPos.x, startPos.y + BLOCK_SIZE);[m
[32m+[m			[32mblocks[2].setPosition(startPos.x, startPos.y + 2 * BLOCK_SIZE);[m
 			blocks[3].setPosition(startPos.x + BLOCK_SIZE, startPos.y + 2 * BLOCK_SIZE);[m
[32m+[m
[32m+[m			[32mleftPos = blocks[0].getPosition();[m
[32m+[m			[32mrightPos = blocks[3].getPosition();[m
[32m+[m			[32mdownPos = blocks[3].getPosition();[m
[32m+[m			[32mupPos = blocks[0].getPosition();[m
 			break;[m
 		case Figure::J:[m
[31m-			blocks[0].setPosition(startPos.x, startPos.y + 2 * BLOCK_SIZE);[m
[31m-			for (int i = 1; i < 4; i++)[m
[31m-			{[m
[31m-				blocks[i].setPosition(startPos.x + BLOCK_SIZE, startPos.y + (i-1) * BLOCK_SIZE);[m
[31m-			}[m
[32m+[m			[32mblocks[0].setPosition(startPos.x + BLOCK_SIZE, startPos.y);[m
[32m+[m			[32mblocks[1].setPosition(startPos.x + BLOCK_SIZE, startPos.y + BLOCK_SIZE);[m
[32m+[m			[32mblocks[2].setPosition(startPos.x + BLOCK_SIZE, startPos.y + 2 * BLOCK_SIZE);[m
[32m+[m			[32mblocks[3].setPosition(startPos.x, startPos.y + 2 * BLOCK_SIZE);[m
[32m+[m
[32m+[m			[32mleftPos = blocks[3].getPosition();[m
[32m+[m			[32mrightPos = blocks[0].getPosition();[m
[32m+[m			[32mdownPos = blocks[3].getPosition();[m
[32m+[m			[32mupPos = blocks[0].getPosition();[m
 			break;[m
 		case Figure::S:[m
 			blocks[0].setPosition(startPos.x, startPos.y + BLOCK_SIZE);[m
 			blocks[1].setPosition(startPos.x + BLOCK_SIZE, startPos.y);[m
 			blocks[2].setPosition(startPos.x + BLOCK_SIZE, startPos.y + BLOCK_SIZE);[m
 			blocks[3].setPosition(startPos.x + 2 * BLOCK_SIZE, startPos.y);[m
[32m+[m
[32m+[m			[32mleftPos = blocks[0].getPosition();[m
[32m+[m			[32mrightPos = blocks[3].getPosition();[m
[32m+[m			[32mdownPos = blocks[0].getPosition();[m
[32m+[m			[32mupPos = blocks[3].getPosition();[m
 			break;[m
 		case Figure::Z:[m
 			blocks[0].setPosition(startPos.x, startPos.y);[m
 			blocks[1].setPosition(startPos.x + BLOCK_SIZE, startPos.y);[m
 			blocks[2].setPosition(startPos.x + BLOCK_SIZE, startPos.y + BLOCK_SIZE);[m
 			blocks[3].setPosition(startPos.x + 2 * BLOCK_SIZE, startPos.y + BLOCK_SIZE);[m
[32m+[m
[32m+[m			[32mleftPos = blocks[0].getPosition();[m
[32m+[m			[32mrightPos = blocks[3].getPosition();[m
[32m+[m			[32mdownPos = blocks[3].getPosition();[m
[32m+[m			[32mupPos = blocks[0].getPosition();[m
 			break;[m
 		}[m
 	}[m
[36m@@ -78,31 +114,94 @@[m [mnamespace hgw[m
 [m
 	void Figure::AddToGrid(short grid_X, short grid_Y)[m
 	{[m
[31m-		switch (_type_)[m
[32m+[m		[32mswitch (_type_) //set block coordinates on grid[m
 		{[m
[31m-		case hgw::Figure::I:[m
[32m+[m		[32mcase Figure::I:[m
 			gridCoords[0] = std::make_pair(grid_X, grid_Y);[m
[31m-			gridCoords[1] = std::make_pair(grid_X, grid_Y + BLOCK_SIZE);[m
[31m-			gridCoords[2] = std::make_pair(grid_X, grid_Y + 2 * BLOCK_SIZE);[m
[31m-			gridCoords[3] = std::make_pair(grid_X, grid_Y + 3 * BLOCK_SIZE);[m
[31m-			break;[m
[31m-		case hgw::Figure::T:[m
[32m+[m			[32mgridCoords[1] = std::make_pair(grid_X, grid_Y + 1);[m
[32m+[m			[32mgridCoords[2] = std::make_pair(grid_X, grid_Y + 2);[m
[32m+[m			[32mgridCoords[3] = std::make_pair(grid_X, grid_Y + 3);[m
[32m+[m
[32m+[m			[32mpivot = &gridCoords[2]; //set pivot to rotate[m
[32m+[m			[32mleftGridCoord = blocks[0].getPosition(); //set border coordinates to check overlapping[m
[32m+[m			[32mrightGridCoord = blocks[0].getPosition();[m
[32m+[m			[32mdownGridCoord = blocks[3].getPosition();[m
[32m+[m			[32mupGridCoord = blocks[0].getPosition();[m
 			break;[m
[31m-		case hgw::Figure::O:[m
[32m+[m		[32mcase Figure::T:[m
[32m+[m			[32mgridCoords[0] = std::make_pair(grid_X, grid_Y);[m
[32m+[m			[32mgridCoords[1] = std::make_pair(grid_X + 1, grid_Y);[m
[32m+[m			[32mgridCoords[2] = std::make_pair(grid_X + 2, grid_Y);[m
[32m+[m			[32mgridCoords[3] = std::make_pair(grid_X + 1, grid_Y + 1);[m
[32m+[m
[32m+[m			[32mpivot = &gridCoords[3];[m
[32m+[m			[32mleftGridCoord = blocks[0].getPosition();[m
[32m+[m			[32mrightGridCoord = blocks[2].getPosition();[m
[32m+[m			[32mdownGridCoord = blocks[3].getPosition();[m
[32m+[m			[32mupGridCoord = blocks[0].getPosition();[m
 			break;[m
[31m-		case hgw::Figure::L:[m
[32m+[m		[32mcase Figure::O:[m
[32m+[m			[32mgridCoords[0] = std::make_pair(grid_X, grid_Y);[m
[32m+[m			[32mgridCoords[1] = std::make_pair(grid_X + 1, grid_Y);[m
[32m+[m			[32mgridCoords[2] = std::make_pair(grid_X, grid_Y + 1);[m
[32m+[m			[32mgridCoords[3] = std::make_pair(grid_X + 1, grid_Y + 1);[m
[32m+[m
[32m+[m			[32mpivot = nullptr; //O Figure has no pivot/no rotation[m
[32m+[m			[32mleftGridCoord = blocks[0].getPosition();[m
[32m+[m			[32mrightGridCoord = blocks[1].getPosition();[m
[32m+[m			[32mdownGridCoord = blocks[2].getPosition();[m
[32m+[m			[32mupGridCoord = blocks[0].getPosition();[m
 			break;[m
[31m-		case hgw::Figure::J:[m
[32m+[m		[32mcase Figure::L:[m
[32m+[m			[32mgridCoords[0] = std::make_pair(grid_X, grid_Y);[m
[32m+[m			[32mgridCoords[1] = std::make_pair(grid_X, grid_Y + 1);[m
[32m+[m			[32mgridCoords[2] = std::make_pair(grid_X, grid_Y + 2);[m
[32m+[m			[32mgridCoords[3] = std::make_pair(grid_X + 1, grid_Y + 2);[m
[32m+[m
[32m+[m			[32mpivot = &gridCoords[2];[m
[32m+[m			[32mleftGridCoord = blocks[0].getPosition();[m
[32m+[m			[32mrightGridCoord = blocks[3].getPosition();[m
[32m+[m			[32mdownGridCoord = blocks[3].getPosition();[m
[32m+[m			[32mupGridCoord = blocks[0].getPosition();[m
 			break;[m
[31m-		case hgw::Figure::S:[m
[32m+[m		[32mcase Figure::J:[m
[32m+[m			[32mgridCoords[0] = std::make_pair(grid_X + 1, grid_Y);[m
[32m+[m			[32mgridCoords[1] = std::make_pair(grid_X + 1, grid_Y + 1);[m
[32m+[m			[32mgridCoords[2] = std::make_pair(grid_X + 1, grid_Y + 2);[m
[32m+[m			[32mgridCoords[3] = std::make_pair(grid_X, grid_Y + 2);[m
[32m+[m
[32m+[m			[32mpivot = &gridCoords[2];[m
[32m+[m			[32mleftGridCoord = blocks[3].getPosition();[m
[32m+[m			[32mrightGridCoord = blocks[0].getPosition();[m
[32m+[m			[32mdownGridCoord = blocks[3].getPosition();[m
[32m+[m			[32mupGridCoord = blocks[0].getPosition();[m
 			break;[m
[31m-		case hgw::Figure::Z:[m
[32m+[m		[32mcase Figure::S:[m
[32m+[m			[32mgridCoords[0] = std::make_pair(grid_X, grid_Y + 1);[m
[32m+[m			[32mgridCoords[1] = std::make_pair(grid_X + 1, grid_Y);[m
[32m+[m			[32mgridCoords[2] = std::make_pair(grid_X + 1, grid_Y + 1);[m
[32m+[m			[32mgridCoords[3] = std::make_pair(grid_X + 2, grid_Y);[m
[32m+[m
[32m+[m			[32mpivot = &gridCoords[2];[m
[32m+[m			[32mleftGridCoord = blocks[0].getPosition();[m
[32m+[m			[32mrightGridCoord = blocks[3].getPosition();[m
[32m+[m			[32mdownGridCoord = blocks[2].getPosition();[m
[32m+[m			[32mupGridCoord = blocks[1].getPosition();[m
 			break;[m
[31m-		default:[m
[32m+[m		[32mcase Figure::Z:[m
[32m+[m			[32mgridCoords[0] = std::make_pair(grid_X, grid_Y);[m
[32m+[m			[32mgridCoords[1] = std::make_pair(grid_X + 1, grid_Y);[m
[32m+[m			[32mgridCoords[2] = std::make_pair(grid_X + 1, grid_Y + 1);[m
[32m+[m			[32mgridCoords[3] = std::make_pair(grid_X + 2, grid_Y + 1);[m
[32m+[m
[32m+[m			[32mpivot = &gridCoords[2];[m
[32m+[m			[32mleftGridCoord = blocks[0].getPosition();[m
[32m+[m			[32mrightGridCoord = blocks[3].getPosition();[m
[32m+[m			[32mdownGridCoord = blocks[3].getPosition();[m
[32m+[m			[32mupGridCoord = blocks[0].getPosition();[m
 			break;[m
 		}[m
 [m
[31m-		gridCoords[0] = std::make_pair(grid_X, grid_Y);[m
 	}[m
 [m
 	GameState::GameState(GameDataRef _data)[m
[36m@@ -112,36 +211,86 @@[m [mnamespace hgw[m
 [m
 	void GameState::Init()[m
 	{[m
[31m-		for (int i = 0; i < 11; i++)[m
[32m+[m		[32mfor (int i = 0; i < 11; i++) //draw a grid[m
 		{[m
 			verticalLines[i].setSize(sf::Vector2f(1, 600));[m
 			verticalLines[i].setPosition(sf::Vector2f(APP_WIDTH / 2 + i*30 - 150, 100));[m
 		}[m
[31m-[m
 		for (int i = 0; i < 21; i++)[m
 		{[m
 			horizontalLines[i].setSize(sf::Vector2f(300, 1));[m
 			horizontalLines[i].setPosition(verticalLines[0].getPosition().x, verticalLines[0].getPosition().y + i * 30);[m
 		}[m
[31m-	}[m
 [m
[32m+[m		[32mgameClock.restart(); //start clock that moves blocks[m
[32m+[m[41m		[m
[32m+[m		[32mint figure = random(0, 6); //create new Figure with random color and random shape[m
[32m+[m		[32msf::Color color = sf::Color(random(0, 255), random(0, 255), random(0, 255), 255);[m
[32m+[m		[32mcurrentFigure = Figure(static_cast<Figure::FigureType>(figure), sf::Vector2f(GRID_START_POS_X, GRID_START_POS_Y), color);[m
[32m+[m		[32mcurrentFigure.AddToGrid(0, 0);[m
[32m+[m	[32m}[m
[32m+[m[41m	[m
 	void GameState::HandleInput()[m
 	{[m
 		sf::Event event;[m
 [m
 		while (_data->window.pollEvent(event))[m
 		{[m
[31m-			std::cout << "X: " << _data->input.GetMousePosition(_data->window).x << "  Y: " << _data->input.GetMousePosition(_data->window).x << std::endl;[m
 			if (sf::Event::Closed == event.type)[m
 			{[m
 				_data->window.close();[m
 			}[m
 [m
[32m+[m			[32mif (sf::Keyboard::isKeyPressed(sf::Keyboard::Right) && currentFigure.rightPos.x <= GRID_END_POS_X - 2 * BLOCK_SIZE) //move right[m
[32m+[m			[32m{[m
[32m+[m				[32mfor (int i = 0; i < 4; i++)[m
[32m+[m				[32m{[m
[32m+[m					[32mcurrentFigure.blocks[i].move(BLOCK_SIZE, 0); //move blocks to right by 30[m[41m [m
[32m+[m					[32mcurrentFigure.gridCoords[i].first++; //set proper grid coords[m
[32m+[m				[32m}[m
[32m+[m				[32mcurrentFigure.rightPos.x += BLOCK_SIZE; //update border positons[m
[32m+[m				[32mcurrentFigure.leftPos.x += BLOCK_SIZE;[m
[32m+[m			[32m}[m
[32m+[m			[32melse if (sf::Keyboard::isKeyPressed(sf::Keyboard::Left) && currentFigure.leftPos.x >= GRID_START_POS_X + BLOCK_SIZE) //move left[m
[32m+[m			[32m{[m
[32m+[m				[32mfor (int i = 0; i < 4; i++)[m
[32m+[m				[32m{[m
[32m+[m					[32mcurrentFigure.blocks[i].move(-BLOCK_SIZE, 0); //move blocks to left by 30[m[41m [m
[32m+[m					[32mcurrentFigure.gridCoords[i].first--; //set proper grid coords[m
[32m+[m				[32m}[m
[32m+[m				[32mcurrentFigure.leftPos.x -= BLOCK_SIZE; //update border positons[m
[32m+[m				[32mcurrentFigure.rightPos.x -= BLOCK_SIZE;[m
[32m+[m			[32m}[m
 		}[m
 	}[m
 [m
 	void GameState::Update(float dt)[m
 	{[m
[32m+[m		[32mif (gameClock.getElapsedTime() >= sf::seconds(0.5) || sf::Keyboard::isKeyPressed(sf::Keyboard::Down)) //Figure falling + fast fall[m
[32m+[m		[32m{[m
[32m+[m			[32mfor (int i = 0; i < 4; i++)[m
[32m+[m			[32m{[m
[32m+[m				[32mcurrentFigure.blocks[i].move(0, BLOCK_SIZE); //move blocks down by 30[m
[32m+[m				[32mcurrentFigure.gridCoords[i].second++; //set proper grid coords[m
[32m+[m			[32m}[m
[32m+[m			[32mcurrentFigure.downPos.y += BLOCK_SIZE; //update border positons[m
[32m+[m			[32mcurrentFigure.upPos.y += BLOCK_SIZE;[m
[32m+[m
[32m+[m			[32mgameClock.restart();[m
[32m+[m		[32m}[m
[32m+[m
[32m+[m		[32mif (currentFigure.downPos.y >= GRID_END_POS_Y - BLOCK_SIZE || willBlockOverlap()) //stop figure[m
[32m+[m		[32m{[m
[32m+[m			[32mfor (int i = 0; i < 4; i++) //add to grid[m
[32m+[m			[32m{[m
[32m+[m				[32mgrid[currentFigure.gridCoords[i].first][currentFigure.gridCoords[i].second] = std::make_pair(true, currentFigure.blocks[i]);[m
[32m+[m			[32m}[m
[32m+[m
[32m+[m			[32mint nextFigure = random(0, 6); //create next figure[m
[32m+[m			[32msf::Color nextColor = sf::Color(random(0, 255), random(0, 255), random(0, 255), 255);[m
[32m+[m			[32mcurrentFigure = Figure(static_cast<Figure::FigureType>(nextFigure), sf::Vector2f(GRID_START_POS_X, GRID_START_POS_Y), nextColor);[m
[32m+[m			[32mcurrentFigure.AddToGrid(0, 0);[m
[32m+[m		[32m}[m
 [m
 	}[m
 [m
[36m@@ -149,27 +298,51 @@[m [mnamespace hgw[m
 	{[m
 		_data->window.clear();[m
 		[m
[31m-		for (int i = 0; i < 11; i++)[m
[32m+[m		[32mfor (auto &block : currentFigure.blocks) //draw current figure[m
 		{[m
[31m-			_data->window.draw(verticalLines[i]);[m
[32m+[m			[32m_data->window.draw(block);[m
 		}[m
 [m
[32m+[m		[32mfor (int i = 0; i < 10; i++) //draw solid blocks[m
[32m+[m		[32m{[m
[32m+[m			[32mfor (int j = 0; j < 20; j++)[m
[32m+[m			[32m{[m
[32m+[m				[32mif (grid[i][j].first == true) //if block is on grid[m
[32m+[m				[32m{[m
[32m+[m					[32m_data->window.draw(grid[i][j].second);[m
[32m+[m				[32m}[m
[32m+[m			[32m}[m
[32m+[m		[32m}[m
[32m+[m
[32m+[m		[32mfor (int i = 0; i < 11; i++) //draw grid[m
[32m+[m		[32m{[m
[32m+[m			[32m_data->window.draw(verticalLines[i]);[m
[32m+[m		[32m}[m
 		for (int i = 0; i < 21; i++)[m
 		{[m
 			_data->window.draw(horizontalLines[i]);[m
 		}[m
 [m
[32m+[m		[32m_data->window.display();[m
[32m+[m	[32m}[m
[32m+[m
[32m+[m	[32mbool GameState::willBlockOverlap()[m
[32m+[m	[32m{[m
 		for (int i = 0; i < 4; i++)[m
 		{[m
[31m-			_data->window.draw(I.blocks[i]);[m
[31m-			_data->window.draw(T.blocks[i]);[m
[31m-			_data->window.draw(O.blocks[i]);[m
[31m-			_data->window.draw(L.blocks[i]);[m
[31m-			_data->window.draw(J.blocks[i]);[m
[31m-			_data->window.draw(S.blocks[i]);[m
[31m-			_data->window.draw(Z.blocks[i]);[m
[32m+[m			[32mif (grid[currentFigure.gridCoords[i].first][currentFigure.gridCoords[i].second + 1].first == true)[m
[32m+[m			[32m{[m
[32m+[m				[32mreturn true;[m
[32m+[m			[32m}[m
 		}[m
[32m+[m		[32mreturn false;[m
[32m+[m	[32m}[m
 [m
[31m-		_data->window.display();[m
[32m+[m	[32mint GameState::random(int min, int max)[m
[32m+[m	[32m{[m
[32m+[m		[32munsigned seed = std::chrono::system_clock::now().time_since_epoch().count();[m
[32m+[m		[32mstd::mt19937 gen(seed);[m
[32m+[m		[32mstd::uniform_int<int> distrib(min, max);[m
[32m+[m		[32mreturn distrib(gen);[m
 	}[m
 }[m
\ No newline at end of file[m
[1mdiff --git a/Tetris/src/States/hpp/GameState.hpp b/Tetris/src/States/hpp/GameState.hpp[m
[1mindex 11c86bd..c89ac6b 100644[m
[1m--- a/Tetris/src/States/hpp/GameState.hpp[m
[1m+++ b/Tetris/src/States/hpp/GameState.hpp[m
[36m@@ -11,6 +11,7 @@[m [mnamespace hgw[m
 	public:[m
 		enum FigureType { I, T, O, L, J, S, Z};[m
 		Figure(FigureType type, sf::Vector2f startPos, sf::Color color);[m
[32m+[m		[32mFigure() = default;[m
 [m
 		void RotateLeft();[m
 		void RotateRight();[m
[36m@@ -19,10 +20,17 @@[m [mnamespace hgw[m
 		[m
 		std::array<sf::RectangleShape, 4> blocks;[m
 		std::array<std::pair<short, short>, 4> gridCoords;[m
[32m+[m
[32m+[m		[32msf::Vector2f leftPos, rightPos, downPos, upPos;[m
[32m+[m		[32msf::Vector2f leftGridCoord, rightGridCoord, downGridCoord, upGridCoord;[m
[32m+[m
[32m+[m		[32msf::Color figureColor;[m
 	private:[m
 [m
 		short rotation = 0;[m
[32m+[m		[32mstd::pair<short, short>* pivot;[m
 [m
[32m+[m[41m		[m
 		FigureType _type_;[m
 	};[m
 [m
[36m@@ -36,21 +44,18 @@[m [mnamespace hgw[m
 		void Update(float dt);[m
 		void Draw(float dt);[m
 [m
[32m+[m		[32mbool willBlockOverlap();[m
[32m+[m		[32mint random(int min, int max);[m
[32m+[m
 	private:[m
 		GameDataRef _data;[m
 [m
[31m-		std::vector<Figure> figures;[m
[31m-		std::array<std::array<bool, 20>, 10> grid;[m
[32m+[m		[32msf::Clock gameClock;[m
[32m+[m
[32m+[m		[32mFigure currentFigure;[m
 [m
[32m+[m		[32mstd::array<std::array<std::pair<bool, sf::RectangleShape>, 20>, 10> grid;[m
 		std::array<sf::RectangleShape, 11> verticalLines;[m
 		std::array<sf::RectangleShape, 21> horizontalLines;[m
[31m-[m
[31m-		Figure I = Figure(Figure::I, sf::Vector2f(400, 100), sf::Color::Red);[m
[31m-		Figure T = Figure(Figure::T, sf::Vector2f(250, 100), sf::Color::White);[m
[31m-		Figure O = Figure(Figure::O, sf::Vector2f(400, 190), sf::Color::Blue);[m
[31m-		Figure L = Figure(Figure::L, sf::Vector2f(250, 130), sf::Color::Yellow);[m
[31m-		Figure J = Figure(Figure::J, sf::Vector2f(400, 220), sf::Color::Magenta);[m
[31m-		Figure S = Figure(Figure::S, sf::Vector2f(250, 310), sf::Color::Cyan);[m
[31m-		Figure Z = Figure(Figure::Z, sf::Vector2f(400, 310), sf::Color::Green);[m
 	};[m
 }[m
\ No newline at end of file[m
